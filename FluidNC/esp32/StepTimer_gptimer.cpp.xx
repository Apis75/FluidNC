// Copyright 2022 Mitch Bradley
//
// Interface to the ESP32 alarm timer for step timing

#ifdef __cplusplus
extern "C" {
#endif

// #include "../src/Driver/StepTimer.h"
#include "driver/timer.h"
#include "hal/timer_hal.h"

static const uint32_t fTimers = 80000000;  // the frequency of ESP32 timers

#include "driver/gptimer.h"

static gptimer_handle_t gptimer = NULL;
void                    stepTimerInit(uint32_t frequency, bool (*fn)(void)) {
    gptimer_config_t timer_config = {
        .clk_src       = GPTIMER_CLK_SRC_DEFAULT,
        .direction     = GPTIMER_COUNT_UP,
        .resolution_hz = frequency,
    };
    gptimer_new_timer(&timer_config, &gptimer);

    gptimer_event_callbacks_t cbs = {
        .on_alarm = step_timer_cb,
    };
    gptimer_register_event_callbacks(gptimer, &cbs, NULL);

    gptimer_alarm_config_t alarm_config = {
        .alarm_count = 1000000,  // period = 1s
    };
    gptimer_set_alarm_action(gptimer, &alarm_config);
    gptimer_pause(gptimer);
}

void IRAM_ATTR stepTimerStart() {
    gptimer_alarm_config_t alarm_config = {
        .reload_count               = 0,
        .alarm_count                = 1,  // Trigger immediately for first pulse
        .flags.auto_reload_on_alarm = false,
    };
    gptimer_set_alarm_action(gptimer, &alarm_config);
}

void IRAM_ATTR stepTimerSetTicks(uint32_t ticks) {
    gptimer_alarm_config_t alarm_config = {
        .reload_count               = 0,
        .alarm_count                = ticks,  // Trigger immediately for first pulse
        .flags.auto_reload_on_alarm = true,
    };
    gptimer_set_alarm_action(gptimer, &alarm_config);
}

void IRAM_ATTR stepTimerStop() {
    gptimer_stop(gptimer);
}

#ifdef __cplusplus
}
#endif
